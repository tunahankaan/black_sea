# -*- coding: utf-8 -*-
"""FinancialDataAnalysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18pnQfb0NbU3dYYIPCpZUnfMHokUdXU-x
"""

pip install yahoofinancials

pip install plotly

pip install statsmodels

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from yahoofinancials import YahooFinancials
import plotly.graph_objects as go

vest_df = yf.download('VESTL.IS',
                       start = '2017-01-01',
                       progress = False)

vest_df.index = pd.to_datetime(vest_df.index)

vest_df

##Veri Görselleştirme

#Plotly kütüphanesini kullanarak bir mum çubuğu grafiği oluşturur.
#go.Candlestick objesi, mum çubuğu grafiği oluşturmak için kullanılır.
fig = go.Figure(data=[go.Candlestick(x=vest_df.index,
                                     open = vest_df['Open'],
                                     high = vest_df['High'],
                                     low = vest_df['Low'],
                                     close = vest_df['Close'])])

fig.show()

##Tanımlayıcı istatistikler

vest_df.describe()

##Hareketli Ortalama

close_app = vest_df.iloc[len(vest_df)//2:,3]

close_app

# 5 günlük ortalama
rolling_app5 = close_app.rolling(window=5).mean()

# 14 günlük ortalama
rolling_app14 = close_app.rolling(window=14).mean()

# 21 günlük ortalama
rolling_app21 = close_app.rolling(window=21).mean()

MAs = pd.concat([close_app,rolling_app5,rolling_app14,rolling_app21],axis=1)
MAs.columns = ['Close','Short','Mid','Long']
MAs.head(25)

##DataFrame içindeki NaN değerleri (dropna), yani eksik verileri kaldırır.
##axis = 0 argümanı, satırları (gözlemleri) işaret eder
MAs.dropna(axis = 0, inplace = True)
MAs.head()

##figsize=(20,10) parametresi, grafiğin genişliğini ve yüksekliğini belirler.
##Her ax.plot çağrısı, bir çizgi çizmek için gereken verileri ve çizginin etiketini içerir.
fig, ax = plt.subplots(figsize=(12,4))
ax.plot(close_app.index, close_app, label='Vestel')
ax.plot(rolling_app5.index, rolling_app5, label='5 days rolling')
ax.plot(rolling_app14.index, rolling_app14, label='14 days rolling')
ax.plot(rolling_app21.index, rolling_app21, label='21 days rolling')
ax.legend(loc='upper left')

MAs['Short']-MAs['Mid']

np.array(MAs['Short']-MAs['Mid'])

# Short ve Mid değerleri arasındaki tüm değerler içindeki en küçük %10. değeri
##Amaç uzaklıklar arasındaki optimum uzaklık
np.abs(np.percentile(np.array(MAs['Short']-MAs['Mid']),10))

def buy_sell(data, perc = 10):
  buy_sell = []
  buy_signal = []
  sell_signal = []
  flag = 42
  sm = np.abs(np.percentile(np.array(data['Short']-data['Mid']),perc))
  sl = np.abs(np.percentile(np.array(data['Short']-data['Long']),perc))


  for i in range(0,len(data)):
    if (data['Short'][i] > data['Mid'][i]+sm) & (data['Short'][i] > data['Long'][i]+sl):
      buy_signal.append(np.nan)
      if flag != 1:
        sell_signal.append(data['Close'][i])
        buy_sell.append(data['Close'][i])
        flag = 1
      else:
        sell_signal.append(np.nan)
    elif (data['Short'][i] < data['Mid'][i]-sm ) & (data['Short'][i] < data['Long'][i]-sl):
      sell_signal.append(np.nan)
      if flag != 0:
        buy_signal.append(data['Close'][i])
        buy_sell.append(-data['Close'][i])
        flag = 0
      else :
        buy_signal.append(np.nan)
    else :
      buy_signal.append(np.nan)
      sell_signal.append(np.nan)
      buy_sell.append(np.nan)
  operations = np.array(buy_sell)
  operations = operations[~np.isnan(operations)]
  return buy_signal, sell_signal

#Satış-alış
m=buy_sell(MAs)
m

MAs.tail()

m[0]

m[1]

MAs['BUY']=m[0]
MAs['SELL']=m[1]

plt.figure(figsize=(10,5))
plt.scatter(MAs.index, MAs['BUY'], color = 'green', label = 'BUY', marker = '^', alpha = 1)
plt.scatter(MAs.index, MAs['SELL'], color = 'red', label = 'SELL', marker = 'v', alpha = 1)
plt.plot(MAs['Close'], label = 'Close Price', alpha = 0.5)
plt.title('Close Price Buy and Sell Signal')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend('upper left')
plt.show

neg = 0
  pos = 0
  for i in range(len(operations)):
    if operations[i] < 0:
      neg = i
      break
  for i in range(1,len(operations)):
    if operations[-i] > 0:
      pos = i-1
      break
  operations = operations[neg:-pos]
  PL = np.sum(operations)

  return (buy_signal,sell_signal, PL)

















